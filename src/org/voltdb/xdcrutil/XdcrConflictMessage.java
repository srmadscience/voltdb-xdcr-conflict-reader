package org.voltdb.xdcrutil;

import java.io.IOException;
import java.util.Date;

import org.voltdb.client.Client;
import org.voltdb.client.NoConnectionsException;
import org.voltdb.client.ProcCallException;
import org.voltdb.client.ProcedureCallback;
import org.voltdb.types.*;

import com.google.gson.Gson;

/**
 * Java representation of a VoltDB XDCR conflict message.
 *
 */
public class XdcrConflictMessage {

	// Metadata columns
	// See https://docs.voltdb.com/UsingVoltDB/exportexport.php#ExportMetadataTable

	long m_transactionId;

	TimestampType m_exportGenerationTime;

	long m_seqno;

	long m_partitionId;

	long m_siteId;

	byte m_exportOperation;

	// XDCR Columns
	// See https://docs.voltdb.com/UsingVoltDB/DbRepHowToActive.php#DbRepActiveLogTab

	TimestampType m_eventTime;

	XdcrRowType m_rowType;

	XdcrActionType m_actionType;

	XdcrConflictType m_conflictType;

	boolean m_primaryKeyConflict;

	boolean m_wasAccepted;

	byte m_lastModClusterId;

	TimestampType m_rowTimeststamp;

	boolean m_isStillConsistent;

	String m_tableName;

	byte m_currentClusterId;

	TimestampType m_conflictTimeststamp;

	String m_JsonEncodedTuple;
	
	UserTable m_tuple;
	
	//
	
	Gson gson = new Gson(); //TODO slow

	/**
	 * @param key - assumed to be unixtime
	 * @param message - CSV generated by VoltDB's XDCR conflict resolver.
	 * @throws XdcrFormatException 
	 */
	public XdcrConflictMessage(String key, String message) throws XdcrFormatException {

		try {
			this.m_eventTime = new TimestampType(Long.parseLong(key));
		} catch (Exception e1) {
			throw new XdcrFormatException("Unrecognized event time : " + key);
		}

		// Most of the message can be handled by splitting based on ','.
		String[] payload = message.split("\",\"");

		try {
			m_transactionId = Long.parseLong(payload[0].replace("\"", ""));
		} catch (NumberFormatException e1) {
			throw new XdcrFormatException("Unrecognized transactionId : " + payload[0]);
		}

		try {
			m_exportGenerationTime = new TimestampType(Long.parseLong(payload[1]));
		} catch (Exception e1) {
			throw new XdcrFormatException("Unrecognized exportGenerationTime : " + payload[0]);
		}

		try {
			m_seqno = Long.parseLong(payload[2]);
		} catch (NumberFormatException e1) {
			throw new XdcrFormatException("Unrecognized seqno : " + payload[2]);
		}

		try {
			m_partitionId = Long.parseLong(payload[3]);
		} catch (NumberFormatException e1) {
			throw new XdcrFormatException("Unrecognized partitionId : " + payload[3]);
		}

		try {
			m_siteId = Long.parseLong(payload[4]);
		} catch (NumberFormatException e1) {
			throw new XdcrFormatException("Unrecognized siteId : " + payload[3]);
		}

		try {
			m_exportOperation = Byte.parseByte(payload[5]);
		} catch (NumberFormatException e1) {
			throw new XdcrFormatException("Unrecognized exportOperation : " + payload[5]);
		}

		m_rowType = XdcrUtils.getRowType(payload[6]);
		m_actionType = XdcrUtils.getActionType(payload[7]);
		m_conflictType = XdcrUtils.getConflictType(payload[8]);

		if (payload[9].equals("1")) {
			m_primaryKeyConflict = true;
		} else if (payload[9].equals("0")) {
			m_primaryKeyConflict = false;
		} else {
			throw new XdcrFormatException("Unrecognized primaryKeyConflict: " + payload[9]);
		}

		if (payload[10].equals("A")) {
			m_wasAccepted = true;
		} else if (payload[10].equals("R")) {
			m_wasAccepted = false;
		} else {
			throw new XdcrFormatException("Unrecognized DECISION: " + payload[10]);
		}

		try {
			m_lastModClusterId = Byte.parseByte(payload[11]);
		} catch (NumberFormatException e) {
			throw new XdcrFormatException("Unrecognized last mod cluster id: " + payload[11]);
		}

		try {
			m_rowTimeststamp = new TimestampType(Long.parseLong(payload[12]));
		} catch (Exception e) {
			throw new XdcrFormatException("Unrecognized row timestamp: " + payload[12]);
		}

		if (payload[13].equals("C")) {
			m_isStillConsistent = true;
		} else if (payload[13].equals("D")) {
			m_isStillConsistent = false;
		} else {
			throw new XdcrFormatException("Unrecognized DIVERGENCE: " + payload[13]);
		}

		m_tableName = payload[14];

		try {
			m_currentClusterId = Byte.parseByte(payload[15]);
		} catch (NumberFormatException e) {
			throw new XdcrFormatException("Unrecognized current cluster id: " + payload[15]);
		}

		try {
			m_conflictTimeststamp = new TimestampType(Long.parseLong(payload[16]));
		} catch (Exception e) {
			throw new XdcrFormatException("Unrecognized conflict timestamp: " + payload[16]);
		}

		
		// The last part of the message is a JSON tuple. Because this has embedded ,'s we 
		// don't use the String[] we created earlier. Instead we figure out where it starts.
		int startOfTuple = 0;

		for (int i = 0; i <= 16; i++) {
			startOfTuple += payload[i].length() + 3;
		}

		m_JsonEncodedTuple = message.substring(startOfTuple);
		m_JsonEncodedTuple = m_JsonEncodedTuple.substring(0,m_JsonEncodedTuple.length()-1);

		m_JsonEncodedTuple = m_JsonEncodedTuple.replace("\"\"", "\"");

		if (m_JsonEncodedTuple.equals("NULL\"")) {
			m_JsonEncodedTuple = "";
		} else {
			// Try and create UserTable entry
			
			// Replace field names so GSON will work...
			String alteredJson = new String(m_JsonEncodedTuple);
			
			
			
		}
		
	}

	@Override
	public String toString() {
		StringBuilder builder = new StringBuilder();
		builder.append("XdcrConflictMessage [transactionId=");
		builder.append(m_transactionId);
		builder.append(", exportGenerationTime=");
		builder.append(m_exportGenerationTime);
		builder.append(", seqno=");
		builder.append(m_seqno);
		builder.append(", partitionId=");
		builder.append(m_partitionId);
		builder.append(", siteId=");
		builder.append(m_siteId);
		builder.append(", exportOperation=");
		builder.append(m_exportOperation);
		builder.append(", eventTime=");
		builder.append(m_eventTime);
		builder.append(", rowType=");
		builder.append(m_rowType);
		builder.append(", actionType=");
		builder.append(m_actionType);
		builder.append(", conflictType=");
		builder.append(m_conflictType);
		builder.append(", primaryKeyConflict=");
		builder.append(m_primaryKeyConflict);
		builder.append(", wasAccepted=");
		builder.append(m_wasAccepted);
		builder.append(", lastModClusterId=");
		builder.append(m_lastModClusterId);
		builder.append(", rowTimeststamp=");
		builder.append(m_rowTimeststamp);
		builder.append(", isConsistant=");
		builder.append(m_isStillConsistent);
		builder.append(", tableName=");
		builder.append(m_tableName);
		builder.append(", currentClusterId=");
		builder.append(m_currentClusterId);
		builder.append(", conflictTimeststamp=");
		builder.append(m_conflictTimeststamp);
		builder.append(", tuple=");
		builder.append(m_JsonEncodedTuple);
		builder.append("]");
		return builder.toString();
	}

	/**
	 * @return A String with a subset of useful columns
	 */
	public String toShortString() {
		StringBuilder builder = new StringBuilder();
		builder.append("XdcrConflictMessage [transactionId=");
		builder.append(m_transactionId);
		builder.append(", conflictTimeststamp=");
		builder.append(m_conflictTimeststamp);
		builder.append(", cc=");
		builder.append(m_currentClusterId);
		builder.append(", rowType=");
		builder.append(m_rowType);
		builder.append(", actionType=");
		builder.append(m_actionType);
		builder.append(", conflictType=");
		builder.append(m_conflictType);
		builder.append(", pkConflict=");
		builder.append(m_primaryKeyConflict);
		builder.append(", ok=");
		builder.append(m_wasAccepted);
		builder.append(", lmc=");
		builder.append(m_lastModClusterId);
		builder.append(", rowTimeststamp=");
		builder.append(m_rowTimeststamp);
		builder.append(", con=");
		builder.append(m_isStillConsistent);
		builder.append(", tableName=");
		builder.append(m_tableName);
		builder.append(", tuple=");
		builder.append(m_JsonEncodedTuple);
		builder.append("]");
		return builder.toString();
	}

	/**
	 * Insert this row into VoltDB.
	 * @param theCallback
	 * @param theClient
	 * @param xdcrTableName
	 * @throws NoConnectionsException
	 * @throws IOException
	 * @throws ProcCallException
	 */
	public void insertToVoltDB(ProcedureCallback theCallback, Client theClient, String xdcrTableName)
			throws NoConnectionsException, IOException, ProcCallException {

			theClient.callProcedure(theCallback,xdcrTableName + ".insert",
					// Metadata columns
					m_transactionId,
					m_exportGenerationTime,
					m_seqno,
					m_partitionId,
					m_siteId,
					m_exportOperation,
					// XDCR Columns
					m_eventTime,
					m_rowType.toString(),
					m_actionType.toString(),
					m_conflictType.toString(),
					XdcrUtils.mapBooleanToInt(m_primaryKeyConflict),
					XdcrUtils.mapBooleanToInt(m_wasAccepted),
					m_lastModClusterId,
					m_rowTimeststamp,
					XdcrUtils.mapBooleanToInt(m_isStillConsistent),
					m_tableName,
					m_currentClusterId,
					m_conflictTimeststamp,
					new Date(System.currentTimeMillis()),
					m_JsonEncodedTuple
			);
		

	}

	/**
	 * Convenience method to create needed DDL. Note that we don't 'DR' this table.
	 * @param tableName
	 * @param partitionColumnName
	 * @param jsonColSize
	 * @return a String[] containing DDL statements.
	 */
	public static String[] toDDL(String tableName, String partitionColumnName, int jsonColSize) {

		String[] results = new String[3];

		StringBuilder builder = new StringBuilder();

		builder.append("DROP TABLE ");
		builder.append(tableName);
		builder.append(" IF EXISTS;");

		results[0] = builder.toString();

		builder = new StringBuilder();

		builder.append("CREATE TABLE ");
		builder.append(tableName);
		builder.append("(transactionId BIGINT NOT NULL ");
		builder.append(System.lineSeparator());

		builder.append(",exportGenerationTime TIMESTAMP NOT NULL ");
		builder.append(System.lineSeparator());

		builder.append(",seqno BIGINT NOT NULL ");
		builder.append(System.lineSeparator());

		builder.append(",partitionId BIGINT NOT NULL ");
		builder.append(System.lineSeparator());

		builder.append(",siteId BIGINT NOT NULL ");
		builder.append(System.lineSeparator());

		builder.append(",exportOperation TINYINT NOT NULL ");
		builder.append(System.lineSeparator());

		builder.append(",eventTime TIMESTAMP NOT NULL ");
		builder.append(System.lineSeparator());

		builder.append(",XdcrRowType VARCHAR(3) NOT NULL ");
		builder.append(System.lineSeparator());

		builder.append(",XdcrActionType VARCHAR(1) NOT NULL ");
		builder.append(System.lineSeparator());

		builder.append(",XdcrConflictType VARCHAR(4) NOT NULL ");
		builder.append(System.lineSeparator());

		builder.append(",primaryKeyConflict TINYINT NOT NULL ");
		builder.append(System.lineSeparator());

		builder.append(",wasAccepted TINYINT NOT NULL ");
		builder.append(System.lineSeparator());

		builder.append(",lastModClusterId TINYINT NOT NULL ");
		builder.append(System.lineSeparator());

		builder.append(",rowTimestamp TIMESTAMP NOT NULL ");
		builder.append(System.lineSeparator());

		builder.append(",isConsistant TINYINT NOT NULL ");
		builder.append(System.lineSeparator());

		builder.append(",tableName VARCHAR(80) NOT NULL ");
		builder.append(System.lineSeparator());

		builder.append(",currentClusterId TINYINT NOT NULL ");
		builder.append(System.lineSeparator());

		builder.append(",conflictTimeststamp TIMESTAMP NOT NULL ");
		builder.append(System.lineSeparator());

		builder.append(",inserttime TIMESTAMP NOT NULL ");
		builder.append(System.lineSeparator());

		builder.append(",tupleJson VARCHAR(");
		builder.append(jsonColSize);
		builder.append(") ");
		builder.append(System.lineSeparator());

		builder.append(");");
		builder.append(System.lineSeparator());

		results[1] = builder.toString();
		builder = new StringBuilder();

		builder.append("PARTITION TABLE ");
		builder.append(tableName);
		builder.append(" ON COLUMN ");
		builder.append(partitionColumnName);
		builder.append(";");

		results[2] = builder.toString();

		return results;
	}

	
	
	
}
