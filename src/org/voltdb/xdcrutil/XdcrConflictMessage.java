package org.voltdb.xdcrutil;

import java.io.IOException;
import java.util.Date;

import org.voltdb.client.Client;
import org.voltdb.client.NoConnectionsException;
import org.voltdb.client.ProcCallException;
import org.voltdb.client.ProcedureCallback;
import org.voltdb.types.*;

import com.google.gson.Gson;

/**
 * Java representation of a VoltDB XDCR conflict message.
 *
 */
public class XdcrConflictMessage {

	// Metadata columns
	// See https://docs.voltdb.com/UsingVoltDB/exportexport.php#ExportMetadataTable

    public long m_transactionId;

	public TimestampType m_exportGenerationTime;

	public long m_seqno;

	public long m_partitionId;

	public long m_siteId;

	public byte m_exportOperation;

	// XDCR Columns
	// See https://docs.voltdb.com/UsingVoltDB/DbRepHowToActive.php#DbRepActiveLogTab

	public TimestampType m_eventTime;

	public XdcrRowType m_rowType;

	public XdcrActionType m_actionType;

	public XdcrConflictType m_conflictType;

	public boolean m_primaryKeyConflict;

	public boolean m_wasAccepted;

	public byte m_lastModClusterId;

	public TimestampType m_rowTimeststamp;

	boolean m_isStillConsistent;

	public String m_tableName;

	public byte m_currentClusterId;

	public TimestampType m_conflictTimeststamp;

	public String m_JsonEncodedTuple;
		
	//
	
	Gson gson = new Gson(); //TODO slow

	/**
	 * @param key - assumed to be unixtime
	 * @param message - CSV generated by VoltDB's XDCR conflict resolver.
	 * @throws XdcrFormatException 
	 */
	public XdcrConflictMessage(String key, String message) throws XdcrFormatException {

		try {
			this.m_eventTime = new TimestampType(Long.parseLong(key));
		} catch (Exception e1) {
			throw new XdcrFormatException("Unrecognized event time : " + key);
		}

		// Most of the message can be handled by splitting based on ','.
		String[] payload = message.split("\",\"");

		try {
			m_transactionId = Long.parseLong(payload[0].replace("\"", ""));
		} catch (NumberFormatException e1) {
			throw new XdcrFormatException("Unrecognized transactionId : " + payload[0]);
		}

		try {
			m_exportGenerationTime = new TimestampType(Long.parseLong(payload[1]));
		} catch (Exception e1) {
			throw new XdcrFormatException("Unrecognized exportGenerationTime : " + payload[0]);
		}

		try {
			m_seqno = Long.parseLong(payload[2]);
		} catch (NumberFormatException e1) {
			throw new XdcrFormatException("Unrecognized seqno : " + payload[2]);
		}

		try {
			m_partitionId = Long.parseLong(payload[3]);
		} catch (NumberFormatException e1) {
			throw new XdcrFormatException("Unrecognized partitionId : " + payload[3]);
		}

		try {
			m_siteId = Long.parseLong(payload[4]);
		} catch (NumberFormatException e1) {
			throw new XdcrFormatException("Unrecognized siteId : " + payload[3]);
		}

		try {
			m_exportOperation = Byte.parseByte(payload[5]);
		} catch (NumberFormatException e1) {
			throw new XdcrFormatException("Unrecognized exportOperation : " + payload[5]);
		}

		m_rowType = XdcrUtils.getRowType(payload[6]);
		m_actionType = XdcrUtils.getActionType(payload[7]);
		m_conflictType = XdcrUtils.getConflictType(payload[8]);

		if (payload[9].equals("1")) {
			m_primaryKeyConflict = true;
		} else if (payload[9].equals("0")) {
			m_primaryKeyConflict = false;
		} else {
			throw new XdcrFormatException("Unrecognized primaryKeyConflict: " + payload[9]);
		}

		if (payload[10].equals("A")) {
			m_wasAccepted = true;
		} else if (payload[10].equals("R")) {
			m_wasAccepted = false;
		} else {
			throw new XdcrFormatException("Unrecognized DECISION: " + payload[10]);
		}

		try {
			m_lastModClusterId = Byte.parseByte(payload[11]);
		} catch (NumberFormatException e) {
			throw new XdcrFormatException("Unrecognized last mod cluster id: " + payload[11]);
		}

		try {
			m_rowTimeststamp = new TimestampType(Long.parseLong(payload[12]));
		} catch (Exception e) {
			throw new XdcrFormatException("Unrecognized row timestamp: " + payload[12]);
		}

		if (payload[13].equals("C")) {
			m_isStillConsistent = true;
		} else if (payload[13].equals("D")) {
			m_isStillConsistent = false;
		} else {
			throw new XdcrFormatException("Unrecognized DIVERGENCE: " + payload[13]);
		}

		m_tableName = payload[14];

		try {
			m_currentClusterId = Byte.parseByte(payload[15]);
		} catch (NumberFormatException e) {
			throw new XdcrFormatException("Unrecognized current cluster id: " + payload[15]);
		}

		try {
			m_conflictTimeststamp = new TimestampType(Long.parseLong(payload[16]));
		} catch (Exception e) {
			throw new XdcrFormatException("Unrecognized conflict timestamp: " + payload[16]);
		}

		
		// The last part of the message is a JSON tuple. Because this has embedded ,'s we 
		// don't use the String[] we created earlier. Instead we figure out where it starts.
		int startOfTuple = 0;

		for (int i = 0; i <= 16; i++) {
			startOfTuple += payload[i].length() + 3;
		}

		m_JsonEncodedTuple = message.substring(startOfTuple);
		m_JsonEncodedTuple = m_JsonEncodedTuple.substring(0,m_JsonEncodedTuple.length()-1);

		m_JsonEncodedTuple = m_JsonEncodedTuple.replace("\"\"", "\"");

		if (m_JsonEncodedTuple.equals("NULL\"")) {
			m_JsonEncodedTuple = "";
		} else {
			// Try and create UserTable entry
			
			// Replace field names so GSON will work...
			String alteredJson = new String(m_JsonEncodedTuple);
			
			
			
		}
		
	}

	@Override
	public String toString() {
		StringBuilder builder = new StringBuilder();
		builder.append("XdcrConflictMessage [transactionId=");
		builder.append(m_transactionId);
		builder.append(", exportGenerationTime=");
		builder.append(m_exportGenerationTime);
		builder.append(", seqno=");
		builder.append(m_seqno);
		builder.append(", partitionId=");
		builder.append(m_partitionId);
		builder.append(", siteId=");
		builder.append(m_siteId);
		builder.append(", exportOperation=");
		builder.append(m_exportOperation);
		builder.append(", eventTime=");
		builder.append(m_eventTime);
		builder.append(", rowType=");
		builder.append(m_rowType);
		builder.append(", actionType=");
		builder.append(m_actionType);
		builder.append(", conflictType=");
		builder.append(m_conflictType);
		builder.append(", primaryKeyConflict=");
		builder.append(m_primaryKeyConflict);
		builder.append(", wasAccepted=");
		builder.append(m_wasAccepted);
		builder.append(", lastModClusterId=");
		builder.append(m_lastModClusterId);
		builder.append(", rowTimeststamp=");
		builder.append(m_rowTimeststamp);
		builder.append(", isConsistant=");
		builder.append(m_isStillConsistent);
		builder.append(", tableName=");
		builder.append(m_tableName);
		builder.append(", currentClusterId=");
		builder.append(m_currentClusterId);
		builder.append(", conflictTimeststamp=");
		builder.append(m_conflictTimeststamp);
		builder.append(", tuple=");
		builder.append(m_JsonEncodedTuple);
		builder.append("]");
		return builder.toString();
	}

	/**
	 * @return A String with a subset of useful columns
	 */
	public String toShortString() {
		StringBuilder builder = new StringBuilder();
		builder.append("XdcrConflictMessage [transactionId=");
		builder.append(m_transactionId);
		builder.append(", conflictTimeststamp=");
		builder.append(m_conflictTimeststamp);
		builder.append(", cc=");
		builder.append(m_currentClusterId);
		builder.append(", rowType=");
		builder.append(m_rowType);
		builder.append(", actionType=");
		builder.append(m_actionType);
		builder.append(", conflictType=");
		builder.append(m_conflictType);
		builder.append(", pkConflict=");
		builder.append(m_primaryKeyConflict);
		builder.append(", ok=");
		builder.append(m_wasAccepted);
		builder.append(", lmc=");
		builder.append(m_lastModClusterId);
		builder.append(", rowTimeststamp=");
		builder.append(m_rowTimeststamp);
		builder.append(", con=");
		builder.append(m_isStillConsistent);
		builder.append(", tableName=");
		builder.append(m_tableName);
		builder.append(", tuple=");
		builder.append(m_JsonEncodedTuple);
		builder.append("]");
		return builder.toString();
	}

	/**
	 * Insert this row into VoltDB.
	 * @param theCallback
	 * @param theClient
	 * @param xdcrTableName
	 * @throws NoConnectionsException
	 * @throws IOException
	 * @throws ProcCallException
	 */
	public void insertToVoltDB(ProcedureCallback theCallback, Client theClient, String xdcrTableName)
			throws NoConnectionsException, IOException, ProcCallException {

			theClient.callProcedure(theCallback,xdcrTableName + ".insert",
					// Metadata columns
					m_transactionId,
					m_exportGenerationTime,
					m_seqno,
					m_partitionId,
					m_siteId,
					m_exportOperation,
					// XDCR Columns
					m_eventTime,
					m_rowType.toString(),
					m_actionType.toString(),
					m_conflictType.toString(),
					XdcrUtils.mapBooleanToInt(m_primaryKeyConflict),
					XdcrUtils.mapBooleanToInt(m_wasAccepted),
					m_lastModClusterId,
					m_rowTimeststamp,
					XdcrUtils.mapBooleanToInt(m_isStillConsistent),
					m_tableName,
					m_currentClusterId,
					m_conflictTimeststamp,
					new Date(System.currentTimeMillis()),
					m_JsonEncodedTuple
			);
		

	}
	
	/**
     * Insert this row into VoltDB.
     * @param theCallback
     * @param theClient
     * @param procedureName
     * @throws NoConnectionsException
     * @throws IOException
     * @throws ProcCallException
     */
    public void insertToVoltDBUsingProcedure(ProcedureCallback theCallback, Client theClient, String procedureName)
            throws NoConnectionsException, IOException, ProcCallException {

            theClient.callProcedure(theCallback,procedureName ,
                    // Metadata columns
                    m_transactionId,
                    m_exportGenerationTime,
                    m_seqno,
                    m_partitionId,
                    m_siteId,
                    m_exportOperation,
                    // XDCR Columns
                    m_eventTime,
                    m_rowType.toString(),
                    m_actionType.toString(),
                    m_conflictType.toString(),
                    XdcrUtils.mapBooleanToInt(m_primaryKeyConflict),
                    XdcrUtils.mapBooleanToInt(m_wasAccepted),
                    m_lastModClusterId,
                    m_rowTimeststamp,
                    XdcrUtils.mapBooleanToInt(m_isStillConsistent),
                    m_tableName,
                    m_currentClusterId,
                    m_conflictTimeststamp,
                    m_JsonEncodedTuple
            );
        

    }

	/**
	 * Convenience method to create needed DDL. Note that we don't 'DR' this table.
	 * @param tableName
	 * @param partitionColumnName
	 * @param jsonColSize
	 * @return a String[] containing DDL statements.
	 */
	public static String[] toDDL(String tableName, String partitionColumnName, int jsonColSize) {

		String[] results = new String[4];

		StringBuilder builder = new StringBuilder();

		builder.append("DROP TABLE ");
		builder.append(tableName);
		builder.append(" IF EXISTS;");

		results[0] = builder.toString();

		builder = new StringBuilder();

		builder.append("CREATE TABLE ");
		builder.append(tableName);
		builder.append("(transactionId BIGINT NOT NULL ");
		builder.append(System.lineSeparator());

		builder.append(",exportGenerationTime TIMESTAMP NOT NULL ");
		builder.append(System.lineSeparator());

		builder.append(",seqno BIGINT NOT NULL ");
		builder.append(System.lineSeparator());

		builder.append(",partitionId BIGINT NOT NULL ");
		builder.append(System.lineSeparator());

		builder.append(",siteId BIGINT NOT NULL ");
		builder.append(System.lineSeparator());

		builder.append(",exportOperation TINYINT NOT NULL ");
		builder.append(System.lineSeparator());

		builder.append(",eventTime TIMESTAMP NOT NULL ");
		builder.append(System.lineSeparator());

		builder.append(",XdcrRowType VARCHAR(3) NOT NULL ");
		builder.append(System.lineSeparator());

		builder.append(",XdcrActionType VARCHAR(1) NOT NULL ");
		builder.append(System.lineSeparator());

		builder.append(",XdcrConflictType VARCHAR(4) NOT NULL ");
		builder.append(System.lineSeparator());

		builder.append(",primaryKeyConflict TINYINT NOT NULL ");
		builder.append(System.lineSeparator());

		builder.append(",wasAccepted TINYINT NOT NULL ");
		builder.append(System.lineSeparator());

		builder.append(",lastModClusterId TINYINT NOT NULL ");
		builder.append(System.lineSeparator());

		builder.append(",rowTimestamp TIMESTAMP NOT NULL ");
		builder.append(System.lineSeparator());

		builder.append(",isConsistant TINYINT NOT NULL ");
		builder.append(System.lineSeparator());

		builder.append(",tableName VARCHAR(80) NOT NULL ");
		builder.append(System.lineSeparator());

		builder.append(",currentClusterId TINYINT NOT NULL ");
		builder.append(System.lineSeparator());

		builder.append(",conflictTimestamp TIMESTAMP NOT NULL ");
		builder.append(System.lineSeparator());

		builder.append(",inserttime TIMESTAMP NOT NULL ");
		builder.append(System.lineSeparator());

		builder.append(",tupleJson VARCHAR(");
		builder.append(jsonColSize);
		builder.append(") ");
		builder.append(System.lineSeparator());

		builder.append(");");
		builder.append(System.lineSeparator());

		results[1] = builder.toString();
		builder = new StringBuilder();

		builder.append("PARTITION TABLE ");
		builder.append(tableName);
		builder.append(" ON COLUMN ");
		builder.append(partitionColumnName);
		builder.append(";");

		results[2] = builder.toString();

        builder = new StringBuilder();

        builder.append("CREATE INDEX ");
        builder.append(tableName);
        builder.append("_IX1 ON ");
        builder.append(tableName);
        builder.append(" (transactionId, CONFLICTTIMESTAMP, ");
        builder.append(partitionColumnName);
        builder.append(")");
        builder.append(";");

        results[3] = builder.toString();
        

        
		return results;
	}

    /**
     * @return the m_transactionId
     */
    public long getM_transactionId() {
        return m_transactionId;
    }

    /**
     * @return the m_exportGenerationTime
     */
    public TimestampType getM_exportGenerationTime() {
        return m_exportGenerationTime;
    }

    /**
     * @return the m_seqno
     */
    public long getM_seqno() {
        return m_seqno;
    }

    /**
     * @return the m_partitionId
     */
    public long getM_partitionId() {
        return m_partitionId;
    }

    /**
     * @return the m_siteId
     */
    public long getM_siteId() {
        return m_siteId;
    }

    /**
     * @return the m_exportOperation
     */
    public byte getM_exportOperation() {
        return m_exportOperation;
    }

    /**
     * @return the m_eventTime
     */
    public TimestampType getM_eventTime() {
        return m_eventTime;
    }

    /**
     * @return the m_rowType
     */
    public XdcrRowType getM_rowType() {
        return m_rowType;
    }

    /**
     * @return the m_actionType
     */
    public XdcrActionType getM_actionType() {
        return m_actionType;
    }

    /**
     * @return the m_conflictType
     */
    public XdcrConflictType getM_conflictType() {
        return m_conflictType;
    }

    /**
     * @return the m_primaryKeyConflict
     */
    public boolean isM_primaryKeyConflict() {
        return m_primaryKeyConflict;
    }

    /**
     * @return the m_wasAccepted
     */
    public boolean isM_wasAccepted() {
        return m_wasAccepted;
    }

    /**
     * @return the m_lastModClusterId
     */
    public byte getM_lastModClusterId() {
        return m_lastModClusterId;
    }

    /**
     * @return the m_rowTimeststamp
     */
    public TimestampType getM_rowTimeststamp() {
        return m_rowTimeststamp;
    }

    /**
     * @return the m_isStillConsistent
     */
    public boolean isM_isStillConsistent() {
        return m_isStillConsistent;
    }

    /**
     * @return the m_tableName
     */
    public String getM_tableName() {
        return m_tableName;
    }

    /**
     * @return the m_currentClusterId
     */
    public byte getM_currentClusterId() {
        return m_currentClusterId;
    }

    /**
     * @return the m_conflictTimeststamp
     */
    public TimestampType getM_conflictTimeststamp() {
        return m_conflictTimeststamp;
    }

    /**
     * @return the m_JsonEncodedTuple
     */
    public String getM_JsonEncodedTuple() {
        return m_JsonEncodedTuple;
    }

    /**
     * @return the gson
     */
    public Gson getGson() {
        return gson;
    }

    /**
     * @param m_transactionId the m_transactionId to set
     */
    public void setM_transactionId(long m_transactionId) {
        this.m_transactionId = m_transactionId;
    }

    /**
     * @param m_exportGenerationTime the m_exportGenerationTime to set
     */
    public void setM_exportGenerationTime(TimestampType m_exportGenerationTime) {
        this.m_exportGenerationTime = m_exportGenerationTime;
    }

    /**
     * @param m_seqno the m_seqno to set
     */
    public void setM_seqno(long m_seqno) {
        this.m_seqno = m_seqno;
    }

    /**
     * @param m_partitionId the m_partitionId to set
     */
    public void setM_partitionId(long m_partitionId) {
        this.m_partitionId = m_partitionId;
    }

    /**
     * @param m_siteId the m_siteId to set
     */
    public void setM_siteId(long m_siteId) {
        this.m_siteId = m_siteId;
    }

    /**
     * @param m_exportOperation the m_exportOperation to set
     */
    public void setM_exportOperation(byte m_exportOperation) {
        this.m_exportOperation = m_exportOperation;
    }

    /**
     * @param m_eventTime the m_eventTime to set
     */
    public void setM_eventTime(TimestampType m_eventTime) {
        this.m_eventTime = m_eventTime;
    }

    /**
     * @param m_rowType the m_rowType to set
     */
    public void setM_rowType(XdcrRowType m_rowType) {
        this.m_rowType = m_rowType;
    }

    /**
     * @param m_actionType the m_actionType to set
     */
    public void setM_actionType(XdcrActionType m_actionType) {
        this.m_actionType = m_actionType;
    }

    /**
     * @param m_conflictType the m_conflictType to set
     */
    public void setM_conflictType(XdcrConflictType m_conflictType) {
        this.m_conflictType = m_conflictType;
    }

    /**
     * @param m_primaryKeyConflict the m_primaryKeyConflict to set
     */
    public void setM_primaryKeyConflict(boolean m_primaryKeyConflict) {
        this.m_primaryKeyConflict = m_primaryKeyConflict;
    }

    /**
     * @param m_wasAccepted the m_wasAccepted to set
     */
    public void setM_wasAccepted(boolean m_wasAccepted) {
        this.m_wasAccepted = m_wasAccepted;
    }

    /**
     * @param m_lastModClusterId the m_lastModClusterId to set
     */
    public void setM_lastModClusterId(byte m_lastModClusterId) {
        this.m_lastModClusterId = m_lastModClusterId;
    }

    /**
     * @param m_rowTimeststamp the m_rowTimeststamp to set
     */
    public void setM_rowTimeststamp(TimestampType m_rowTimeststamp) {
        this.m_rowTimeststamp = m_rowTimeststamp;
    }

    /**
     * @param m_isStillConsistent the m_isStillConsistent to set
     */
    public void setM_isStillConsistent(boolean m_isStillConsistent) {
        this.m_isStillConsistent = m_isStillConsistent;
    }

    /**
     * @param m_tableName the m_tableName to set
     */
    public void setM_tableName(String m_tableName) {
        this.m_tableName = m_tableName;
    }

    /**
     * @param m_currentClusterId the m_currentClusterId to set
     */
    public void setM_currentClusterId(byte m_currentClusterId) {
        this.m_currentClusterId = m_currentClusterId;
    }

    /**
     * @param m_conflictTimeststamp the m_conflictTimeststamp to set
     */
    public void setM_conflictTimeststamp(TimestampType m_conflictTimeststamp) {
        this.m_conflictTimeststamp = m_conflictTimeststamp;
    }

    /**
     * @param m_JsonEncodedTuple the m_JsonEncodedTuple to set
     */
    public void setM_JsonEncodedTuple(String m_JsonEncodedTuple) {
        this.m_JsonEncodedTuple = m_JsonEncodedTuple;
    }

    /**
     * @param gson the gson to set
     */
    public void setGson(Gson gson) {
        this.gson = gson;
    }

	
	
	
}
